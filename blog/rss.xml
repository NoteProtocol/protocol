<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Note Protocol Blog</title>
        <link>https://noteprotocol.org/blog</link>
        <description>Note Protocol Blog</description>
        <lastBuildDate>Thu, 04 Apr 2024 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Continuous Upgrades to the NOTE Protocol]]></title>
            <link>https://noteprotocol.org/blog/n20-upgrade</link>
            <guid>https://noteprotocol.org/blog/n20-upgrade</guid>
            <pubDate>Thu, 04 Apr 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Since the public release of its Proof of Concept indexer in February 2024, the NOTE protocol has garnered widespread attention. Following feedback and demands from users, the protocol has been continuously upgraded.]]></description>
            <content:encoded><![CDATA[<p>Since the public release of its Proof of Concept indexer in February 2024, the NOTE protocol has garnered widespread attention. Following feedback and demands from users, the protocol has been continuously upgraded.</p>
<p>As of April 4th, the following upgrades have been implemented:</p>
<ul>
<li>The Payload data area has been fully expanded, meaning that Payload data can now be stored either in the unlocking script or in the redemption script.</li>
<li>Added a Burn method to N20. Tokens can now be burned.</li>
<li>The off-chain contract execution environment has been enriched with a plethora of environmental variables, including block information such as block time, block hash, block height, as well as transaction information like transaction hash, all inputs and outputs. Ticker information, such as the total mint amount, etc., has also been included.</li>
</ul>
<p>The indexer code has undergone extensive refactoring.</p>
<p>One of the goals of this upgrade is to enable anyone to participate in the development of NOTE smart contracts. This allows for the creation of unique smart contracts that can be published to the NOTE indexer, facilitating the issuance of digital assets. A comprehensive tutorial on contract creation is currently being developed.</p>
<p>The capabilities of the NOTE protocol can be seen in the <a href="https://github.com/NoteProtocol/scryptdemo/blob/main/src/contracts/n20-pow.ts" target="_blank" rel="noopener noreferrer">POW mining contract</a> released in February.</p>
<p>We've added some comments to help everyone understand:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Each contract is a subclass of SmartContract, and its member variables are read-only and need to be decorated with @prop().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export class N20_Pow extends SmartContract {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readonly tick: ByteString</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readonly max: bigint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readonly lim: bigint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readonly dec: bigint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readonly bitwork: ByteString</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readonly start: bigint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // If the contract includes member variables, they need to be initialized using a constructor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    constructor(tick: ByteString, max: bigint, lim: bigint, dec: bigint, bitwork: ByteString, start: bigint) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(...arguments)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The identifier of the digital asset, its name.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.tick = tick</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The maximum issuance of the digital asset, if there is no limit, it can be specified as 0.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.max = max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The mining limit per transaction, it cannot exceed the maximum value.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.lim = lim</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The decimal unit of the digital asset, for example, if dec=8, then 1 token should be followed by 8 zeros, all quantity values amt, including max and lim, are affected by this. 100000000 represents 1.00000000.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.dec = dec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Mining difficulty, the required leading characters of each transaction's hash256.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.bitwork = bitwork </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The starting height of the mining contract, used to prevent pre-mining.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.start = start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // The block limit algorithm for mining, needs to be decorated with @method().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getBlockLimit(height: bigint): bigint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(height &gt;= this.start, 'Block height is too low')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Halving occurs every 1000 blocks, the number of halvings is determined by the block height minus the starting height.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let halvings = (height - this.start) / 1000n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // A maximum of 7 halvings.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        halvings = halvings &gt; 7n ? 7n : halvings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The mining quantity limit is halved with each halving. Here, the binary rshift operator is used to perform the division by 2 operation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const subsidy = rshift(this.lim, halvings)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return subsidy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// The quantity limit algorithm for mining, needs to be decorated with @method().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getAmountLimit(currentMined: bigint): bigint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The quantity limit starts from how much of the total amount has already been mined.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let miningAmount = this.lim</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let threshold = this.max / 2n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Loop 7 times, each loop, if the current mined amount reaches the threshold, then the mining amount is halved, and the threshold is updated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (let halving = 0n; halving &lt; 7n; halving++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (currentMined &gt;= threshold) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                miningAmount /= 2n // Halve the mining amount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                threshold += rshift(this.max, halving + 2n) // Update the next threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return miningAmount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public mint(tick: ByteString, amt: bigint, total: bigint, height: bigint, tx: ByteString) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Check if the transaction's hash256 leading characters match the mining contract's difficulty requirement.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const txid = hash256(tx)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(slice(txid, 0n, len(this.bitwork)) == this.bitwork, 'not match target')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Check if the total mining amount exceeds the maximum issuance.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(this.max == 0n || total &lt;= this.max, 'Over max')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(tick == this.tick, 'Tick does not match')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Check if the mining amount exceeds the block limit and the total halving limit.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const limit1 = this.getBlockLimit(height)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const limit2 = this.getAmountLimit(total)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const limit = limit1 &gt; limit2 ? limit2 : limit1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(amt &lt;= limit &amp;&amp; amt &lt;= this.max - total, 'Amount check failed')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // The method for transferring Tokens, needs to be decorated with @method().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public transfer(tick: ByteString) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(tick == this.tick, 'Tick does not match')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>This upgrade added the Burn method, allowing for the burning of Tokens. <a href="https://github.com/NoteProtocol/scryptdemo/blob/main/src/contracts/n20-joss.ts" target="_blank" rel="noopener noreferrer">A new example</a> is as follows.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// This example does not use a constructor but instead uses a static setting of parameters, because the values are entirely within the contract and cannot be reused for other digital assets.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export class N20_Joss extends SmartContract {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Joss paper: A type of paper made to resemble money and burned in front of deities.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static tick: ByteString = toByteString('JOSS', true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // No issuance limit.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static max: bigint = 0n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Can issue 10,000 at a time.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static lim: bigint = 10000n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // No decimal places.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @prop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static dec: bigint = 0n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public mint(tick: ByteString, amt: bigint) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(tick == N20_Joss.tick, 'Tick does not match')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The issuance amount cannot exceed the limit of 10,000.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(amt == N20_Joss.lim, 'Limit does not match')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public transfer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Cannot transfer.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @method()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public burn(tick: ByteString) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Can be burned.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert(tick == N20_Joss.tick, 'Tick does not match')</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Support for smart contracts is the biggest difference between the NOTE protocol and other protocols. The NOTE wallet and indexer create an execution environment for smart contracts, allowing users to write their own smart contracts. For basic knowledge about smart contracts, you can refer to:</p>
<ul>
<li><a href="https://scrypt.io/" target="_blank" rel="noopener noreferrer">sCrypt</a></li>
<li><a href="https://xiaohuiliu.medium.com/" target="_blank" rel="noopener noreferrer">sCrypt Medium</a></li>
</ul>
<p>Why Bitcoin smart contracts are Turing complete:</p>
<ul>
<li><a href="https://medium.com/coinmonks/turing-machine-on-bitcoin-7f0ebe0d52b1" target="_blank" rel="noopener noreferrer">Turing Machines on Bitcoin</a></li>
</ul>
<p>A tutorial on smart contract development for the NOTE protocol is being created, so stay tuned.</p>]]></content:encoded>
            <category>NoteProtocol</category>
        </item>
        <item>
            <title><![CDATA[N20 Token protocol draft is out]]></title>
            <link>https://noteprotocol.org/blog/n20-draft</link>
            <guid>https://noteprotocol.org/blog/n20-draft</guid>
            <pubDate>Wed, 21 Feb 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[The NOTE protocol marks a significant advancement in the history of Bitcoin.]]></description>
            <content:encoded><![CDATA[<p><strong>The NOTE protocol marks a significant advancement in the history of Bitcoin.</strong></p>
<p>The NOTE protocol is a digital asset issuance protocol based on Bitcoin's UTXO model, distinct from many recently emerged protocols, as NOTE is genuinely rooted in Bitcoin's UTXO model. It utilizes a smart contract language compatible with Typescript, whose compilation results in Bitcoin native opcodes, enabling a powerful feature set that includes Oracles and zero-knowledge proofs.</p>
<p>Unlike protocols such as Ordinals and Atomicals, NOTE also uses an indexer to tally user assets, but it is entirely based on cryptography, secured by Bitcoin miners to ensure asset ownership, thus avoiding misoperations due to indexer tagging. Moreover, NOTE's transaction costs are extremely low, eliminating the need to send two transactions as with Ordinals and Atomicals. More importantly, the NOTE protocol supports smart contracts, for instance, enabling Bitwork mining and a diminishing mining quantity over time. It employs actual Token values, not based on prime protocols numbered by Satoshi nor dependent on UTXO balance coloring schemes.</p>
<p>Compared to many "inter-chain bridging protocols," NOTE issues native Bitcoin assets, avoiding operations that involve using BTC as collateral to issue and trade assets on other chains.</p>
<table><thead><tr><th>Protocol</th><th>Ordinals/BRC20</th><th>Atomicals/ARC20</th><th>EVM/Zk Layer2</th><th>NOTE/N20</th></tr></thead><tbody><tr><td>UTXO</td><td>YES</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Bitcoin Assets</td><td>YES</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Smart Contract</td><td>NO</td><td>NO</td><td>YES(EVM)</td><td>YES(Bitcoin OP Codes)</td></tr><tr><td>Indexer</td><td>YES</td><td>YES</td><td>NO</td><td>YES</td></tr><tr><td>Index Logic</td><td>Satoshi Ordinals</td><td>Colored Satoshi</td><td>-</td><td>Cryptography</td></tr><tr><td>Cross Chain Transfer</td><td>NO</td><td>NO</td><td>YES with bridge</td><td>YES</td></tr><tr><td>Fee(Gas)</td><td>High</td><td>High</td><td>Medium-Low</td><td>Low</td></tr><tr><td>Fund</td><td>NO</td><td>unknown</td><td>YES or unknown</td><td>NO</td></tr></tbody></table>
<p>The NOTE protocol supports cross-chain functionality, allowing native assets on Bitcoin to be sent to other UTXO chains, as well as receiving assets from these chains. All of this is based on cryptography and the consensus of the Bitcoin blockchain.</p>
<p>This protocol is entirely the result of open-source contributions from Bitcoin development luminaries, with no institutional investment involved.</p>
<p>Now, let's delve into a detailed <strong>technical interpretation</strong>:</p>
<p>The last bull market was ignited by a large number of institutional investment projects and ultimately collapsed with the downfall of institutions like FTX. Starting from the bear market bottom in 2023, the market has returned to the grassroots and developer enthusiasts' home ground. Inscriptions led the market trend without any investment, bringing the advantages of the UTXO model back into the public eye. As the anchor of digital currency, Bitcoin needs usable and practical technological solutions to achieve asset appreciation and practical applications.</p>
<p>Compared to the EVM, Bitcoin's UTXO model has significant efficiency and concurrency advantages. However, issuing native assets on Bitcoin's UTXO model involves several challenging issues, mainly how assets are identified. Another issue is how assets are preserved in closely linked transactions.</p>
<p>A UTXO-style transaction is illustrated as follows:</p>
<p><img decoding="async" loading="lazy" alt="Image1" src="https://noteprotocol.org/assets/images/n20-1-cde9054912c3c65fdf5c79ee220b87ad.png" width="1050" height="1278" class="img_ev3q"></p>
<p>The NOTE protocol adopts an innovative approach to managing Bitcoin transactions and assets, significantly different from other protocol solutions. In traditional Bitcoin transactions, the input part of a transaction unlocks a previous transaction's output (i.e., the old UTXO) and generates new transaction outputs (i.e., new UTXOs). In other protocol solutions, assets are tied to newly generated UTXOs, causing users' assets to be scattered across different UTXOs. This method requires indexers and wallets to maintain a comprehensive list of UTXOs to ensure the accuracy of asset binding relationships. It also necessitates careful management of UTXOs with asset tags to avoid spending mistakes, and the entire UTXO must be spent at once.</p>
<p>In contrast, the NOTE protocol employs a method that treats transaction outputs as user accounts, where a user's account is represented by the transaction output script hash, as illustrated by the TX1 transaction output in the example. This account is entirely private, and the types and quantities of assets tied to it are derived from the unlocking inputs of TX1. When these assets are spent in TX2, after being unlocked and confirmed by Bitcoin miners, new transaction outputs are generated. During this process, the indexer of the NOTE protocol only needs to record the transaction details disclosed at the time of unlocking and can provide a Merkle proof after block confirmation to verify the transaction's validity.</p>
<p>This design not only simplifies asset tracking and management, reducing the issue of asset fragmentation, but also enhances transaction privacy. By using transaction outputs as accounts and relying on the verification by Bitcoin network miners and the blockchain consensus mechanism, the NOTE protocol offers a more secure, efficient, and privacy-preserving method for managing digital assets.</p>
<p>A typical Taproot P2TR format transaction is illustrated as follows:</p>
<p><img decoding="async" loading="lazy" alt="Image2" src="https://noteprotocol.org/assets/images/n20-2-1af9d959293b44e237e1417fd33f3b81.png" width="2220" height="746" class="img_ev3q"></p>
<p>The technical strategy adopted by the NOTE protocol significantly differs from the Ordinals and Atomicals protocols. Ordinals and Atomicals utilize the redemption script of P2TR (Taproot) to create an inaccessible data area by adding OP_FALSE OP_IF opcodes, embedding additional data. In contrast, the NOTE protocol allows direct manipulation of unlocking data through opcodes, enhancing data usability. In the NOTE protocol, example scripts can directly pop data from the stack, while more complex scripts can perform on-chain checks such as hashlock.</p>
<p>Moreover, the NOTE protocol is not limited to using P2TR; it can also be implemented through P2SH (Pay to Script Hash), P2WSH (Pay to Witness Script Hash), and non-standard scripts, increasing the protocol's flexibility and the capability for cross-chain asset transactions. A key innovation of the NOTE protocol is its use of msgpack encoding instead of json encoding for data, which is more compact and helps reduce the data volume per transaction, thereby lowering transaction costs for users.</p>
<p>In the NOTE protocol, addresses constructed by specific redemption scripts act as user accounts. These account addresses can only be confirmed by miners when correctly unlocked. The asset transaction data contained in the unlocking script is recognized by the indexer upon unlocking and processed by off-chain smart contracts. Only asset transactions verified by off-chain contracts are recorded by the indexer, effectively preventing Bitcoin wallets from mistakenly spending NOTE's UTXO and allowing the recovery of small amounts of Bitcoin (e.g., 546 Satoshi) in UTXOs.</p>
<p>The design of the NOTE protocol considers multiple upgrades to privacy and transaction space optimization in the Bitcoin network since 2017. At the same time, it draws on the large block strategy represented by BSV (Bitcoin SV), delving into the potential of Bitcoin scripting. The smart contract solution of the NOTE protocol is based on the Bitcoin smart contract language developed by the <a href="https://scrypt.io/" target="_blank" rel="noopener noreferrer">sCrypt</a> team, which supports off-chain contract verification. Since the Bitcoin script language is Turing complete and ensures execution within a given script length, indexers are not trapped in infinite loops due to poorly designed smart contracts, ensuring system stability and efficiency.</p>
<p>A demo smart contract project has been released on GitHub.</p>
<p><a href="https://github.com/NoteProtocol/scryptdemo" target="_blank" rel="noopener noreferrer">https://github.com/NoteProtocol/scryptdemo</a></p>
<p><img decoding="async" loading="lazy" alt="Image3" src="https://noteprotocol.org/assets/images/n20-3-f5e48b9da809ebcf49af3a978d9b7b58.png" width="1106" height="299" class="img_ev3q"></p>
<p>It demonstrates the capability of the NOTE protocol to implement complex logic on the Bitcoin network through simulating Bitcoin mining's halving mechanism and Atomicals' Bitwork difficulty mining with a PoW contract. By generating a 1KB Bitcoin script, the contract allows indexers to call and verify whether transactions comply with the protocol, showcasing the feasibility and flexibility of smart contracts on the Bitcoin network.</p>
<p>The use of Rabin signature algorithm Oracles and complex contracts based on zero-knowledge proofs provides a higher level of security and privacy protection. These technologies play a crucial role in the implementation of smart contracts, especially when verifying specific conditions or executing particular logic.</p>
<p>Leveraging these smart contracts, asset issuance on Bitcoin can be used to realize real-world application scenarios, such as bounty scenarios for solving problems with AI. In such scenarios, anyone who can submit a verifiable computational result can receive a reward. This not only demonstrates the practicality of Bitcoin smart contracts but also shows how they can facilitate the realization of complex applications beyond traditional financial transactions and asset management.</p>
<p>The application prospects and implementation mechanisms of smart contracts on the Bitcoin network reflect an important direction in the development of cryptocurrency technology: combining blockchain's decentralization and immutability with complex business logic and application scenarios to explore new possibilities. For those interested in delving deeper or participating in development, following and learning from these smart contract projects and their implementations on GitHub is undoubtedly a valuable resource.</p>
<p>The latest developments and announcements of the NOTE protocol showcase its depth and breadth in the blockchain technology field. The issuance of N20 Token assets is just one of the many functions of the NOTE protocol. It also includes DID (Decentralized Identity), encrypted data, and ownership identification, and with the formulation and verification process of N721 NFTs and Alias (Bitcoin alias system), the capabilities and application scope of the NOTE protocol are expected to expand further.</p>
<p>Currently, to allow users to experience the minting and transferring of N20 Tokens, a command-line wallet has been released on GitHub, and an open-source indexer is also planned to be released. The openness of these tools and resources aims to encourage community member participation and practical experience with the NOTE protocol's functions, thereby accelerating the protocol's testing, improvement, and application development.</p>
<p>The open-source contributors behind the NOTE protocol emphasize that all content is for technical discussion only, and any asset issuance and speculation are unrelated to the contributors. This stance encourages a community environment centered on technology and innovation, rather than speculation and investment.</p>
<p>As the NOTE protocol continues to be developed and refined, it is foreseeable that more real applications based on this protocol will emerge. These applications will leverage the unique functions and advantages of the NOTE protocol to create new value and possibilities in Bitcoin and broader blockchain fields. The ongoing contributions and collaborative spirit of the open-source community are indispensable forces driving this process.</p>
<p><strong>Summary</strong></p>
<p>The NOTE protocol represents a significant advancement in the expansion of the Bitcoin network towards smart contract functionality. By introducing smart contracts to Bitcoin, the most original and widely used cryptocurrency platform, the NOTE protocol not only enhances Bitcoin's functionality but also offers unprecedented possibilities for innovation to developers and users. Here are several key features of the NOTE protocol:</p>
<p>Smart Contract Support: The NOTE protocol extends the application range of Bitcoin through smart contracts, allowing for the creation and execution of more complex logic and transaction types on the Bitcoin network. This includes, but is not limited to, asset issuance, decentralized finance (DeFi) applications, and other scenarios requiring conditional execution.</p>
<p>UTXO-based Model: Unlike account-based smart contract platforms, the NOTE protocol is built on Bitcoin's UTXO model, leveraging Bitcoin's security and efficiency.</p>
<p>Cross-chain Functionality: The NOTE protocol supports cross-chain transactions, enabling digital assets to move between different UTXO chains, further enhancing its flexibility and application scope.</p>
<p>Real-world Applications: The NOTE protocol supports advanced cryptographic technologies, such as zero-knowledge proofs and Rabin signature algorithms, which can be applied in more complex real-world application scenarios.</p>
<p>Low Cost and High Efficiency: By optimizing data storage and using msgpack encoding, the NOTE protocol aims to reduce transaction costs and improve network efficiency.</p>
<p>Open Source and Community-driven: The NOTE protocol emphasizes the spirit of open source and community contribution, promoting the transparency and trustworthiness of the technology while also encouraging broader development and application innovation.</p>
<p>As the NOTE protocol continues to develop and its applications deepen, we can expect to see more innovative applications and services emerging in the Bitcoin ecosystem, all of which will provide users with richer functionality and a better experience while maintaining Bitcoin's core values.</p>
<p>Website: <a href="https://noteprotocol.org/" target="_blank" rel="noopener noreferrer">https://noteprotocol.org</a></p>
<p>X: <a href="https://twitter.com/NoteProtocol" target="_blank" rel="noopener noreferrer">https://twitter.com/NoteProtocol</a></p>
<p>GitHub: <a href="https://github.com/NoteProtocol" target="_blank" rel="noopener noreferrer">https://github.com/NoteProtocol</a></p>
<p>Smart Contract Language: <a href="https://docs.scrypt.io/" target="_blank" rel="noopener noreferrer">https://docs.scrypt.io/</a></p>]]></content:encoded>
            <category>N20</category>
            <category>Draft</category>
        </item>
        <item>
            <title><![CDATA[NoteProtocol v2.0 Draft is out]]></title>
            <link>https://noteprotocol.org/blog/release-2.0-draft</link>
            <guid>https://noteprotocol.org/blog/release-2.0-draft</guid>
            <pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[🚀 Exciting update from our team: We’ve crafted a #Bitcoin protocol, tailored for #UTXO-based blockchains. This protocol not only allows for the creation of tokens and NFTs but also integrates optional data #encryption, #SmartContracts, and #DID definitions, all under the MIT License.]]></description>
            <content:encoded><![CDATA[<p>🚀 Exciting update from our team: We’ve crafted a #Bitcoin protocol, tailored for #UTXO-based blockchains. This protocol not only allows for the creation of tokens and NFTs but also integrates optional data #encryption, #SmartContracts, and #DID definitions, all under the MIT License.</p>
<p>🔬 The first segment has been successfully tested on #BTC, #RXD, and #BSV networks. The #NFT/#Token/Indexer features are nearing completion, with a January release following thorough validation to ensure a high-security standard.</p>
<p>🌍 As we move forward, we’re inviting the community to contribute to this evolving project. Our goal is to establish a protocol committee of contributors, dedicated to promoting and enhancing the protocol, ensuring it serves the global Bitcoin community effectively.</p>
<p>🔧 Your input is vital in this journey of innovation and collaboration. We’re here to support projects leveraging this protocol, fostering a secure and dynamic blockchain ecosystem.</p>
<p>🔔 Stay connected for detailed updates and be part of shaping the future of blockchain technology. #BlockchainEngineering #BitcoinProtocol #DecentralizedInnovation #OpenSourceFuture</p>
<p>Happy New Year everyone!</p>]]></content:encoded>
            <category>NoteProtocol</category>
        </item>
    </channel>
</rss>